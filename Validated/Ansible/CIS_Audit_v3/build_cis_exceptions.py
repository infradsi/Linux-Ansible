#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
Scan /reports/<server>/ for the newest CSV generated by the CIS audit,
and create /reports/<server>/CIS/cis-<ID>.txt for each non-compliant test,
with the content "Specify reason for not compliant".
Existing files are preserved (not overwritten).

Usage:
  sudo python3 build_cis_exceptions_from_csv.py
Optional:
  --root /reports         # change base reports root
  --dry-run               # show what would be created
  --verbose               # print progress
"""

import argparse
import csv
import os
import re
import sys
from pathlib import Path

NON_COMPLIANT_SET = {
    "NOT COMPLIANT", "NOT_COMPLIANT", "NON COMPLIANT", "NON-COMPLIANT",
    "FAIL", "FAILED", "NOK", "NO", "KO"
}
COMPLIANT_SET = {"OK", "PASS", "PASSED", "COMPLIANT", "YES"}
IGNORED_SET = {"MANUAL CHECK REQUIRED", "NA", "N/A", "NOT APPLICABLE"}

# Candidate header names (case-insensitive)
STATUS_HEADERS = ["status", "result", "compliance", "compliant", "state", "outcome"]
ID_HEADERS = ["cis_id", "control", "test", "check", "rule", "id", "benchmark", "section"]

ID_RE = re.compile(r"\b\d+(?:\.\d+)+\b")  # matches 1.1, 1.1.1.2, etc.

def norm(s: str) -> str:
    return (s or "").strip().strip('"').strip().upper()

def pick_column(headers, candidates):
    hdr_map = {h.lower(): i for i, h in enumerate(headers)}
    for cand in candidates:
        if cand in hdr_map:
            return hdr_map[cand]
    # try relaxed match (contains)
    for cand in candidates:
        for h, i in hdr_map.items():
            if cand in h:
                return i
    return None

def extract_id_from_row(row_vals):
    # 1) look in dedicated id column if any
    for v in row_vals:
        if not v:
            continue
        m = ID_RE.search(str(v))
        if m:
            return m.group(0)
    return None

def is_non_compliant(status_value):
    s = norm(status_value)
    if not s:
        return False
    if s in IGNORED_SET:
        return False
    if s in COMPLIANT_SET:
        return False
    if s in NON_COMPLIANT_SET:
        return True
    # also catch booleans like "false" in a "compliant" column
    if s in {"FALSE", "KO", "0"}:
        return True
    # heuristics: if it contains "NOT" and "COMPL" as in "Not compliant"
    if "NOT" in s and "COMPL" in s:
        return True
    if "FAIL" in s:
        return True
    return False

def newest_csv(server_dir: Path):
    csvs = [p for p in server_dir.glob("*.csv") if p.is_file()]
    return max(csvs, key=lambda p: p.stat().st_mtime, default=None)

def process_csv(csv_path: Path, cis_dir: Path, dry: bool, verbose: bool):
    created = 0
    with csv_path.open("r", newline="", encoding="utf-8", errors="replace") as f:
        reader = csv.reader(f)
        try:
            headers = next(reader)
        except StopIteration:
            return 0

        # Normalize headers for detection
        headers_norm = [h.strip().lower() for h in headers]
        status_idx = pick_column(headers_norm, STATUS_HEADERS)
        id_idx = pick_column(headers_norm, ID_HEADERS)

        for row in reader:
            if not row:
                continue

            # Fetch status
            status_val = row[status_idx] if status_idx is not None and status_idx < len(row) else ""
            if not is_non_compliant(status_val):
                continue

            # Determine CIS ID
            id_candidates = []
            if id_idx is not None and id_idx < len(row):
                id_candidates.append(row[id_idx])
            # fallback: inspect all fields for a dotted numeric id
            test_id = None
            test_id = extract_id_from_row(id_candidates) or extract_id_from_row(row)

            if not test_id:
                # Could not identify an ID; skip safely
                if verbose:
                    print(f"[WARN] No CIS ID found in row for {csv_path.name}: {row[:3]}...")
                continue

            filename = f"cis-{test_id}.txt"
            target = cis_dir / filename

            if target.exists():
                if verbose:
                    print(f"[SKIP] {target} already exists")
                continue

            if dry:
                print(f"[DRY] Would create {target}")
            else:
                cis_dir.mkdir(parents=True, exist_ok=True)
                target.write_text("Specify reason for not compliant\n", encoding="utf-8")
                created += 1
                if verbose:
                    print(f"[NEW]  {target}")

    return created

def main():
    parser = argparse.ArgumentParser()
    parser.add_argument("--root", default="/reports", help="Base path containing per-server folders")
    parser.add_argument("--dry-run", action="store_true", help="Do not write files; just show actions")
    parser.add_argument("--verbose", action="store_true", help="Verbose output")
    args = parser.parse_args()

    root = Path(args.root)
    if not root.is_dir():
        print(f"ERROR: {root} not found or not a directory", file=sys.stderr)
        sys.exit(2)

    total_created = 0
    servers = sorted([p for p in root.iterdir() if p.is_dir()])
    if args.verbose:
        print(f"Found {len(servers)} server folder(s) under {root}")

    for server_dir in servers:
        csv_path = newest_csv(server_dir)
        if not csv_path:
            if args.verbose:
                print(f"[INFO] No CSV in {server_dir}, skipping")
            continue

        cis_dir = server_dir / "CIS"
        if args.verbose:
            print(f"[PROC] {server_dir.name}: newest CSV -> {csv_path.name}")

        created = process_csv(csv_path, cis_dir, args.dry_run, args.verbose)
        total_created += created

    if args.verbose or args.dry_run:
        print(f"Done. New files created: {total_created}")

if __name__ == "__main__":
    main()
